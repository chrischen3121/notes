<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN">
<head>
<!-- 2021-02-13 Sat 00:04 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>设计模式</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="ChrisChen" />
<meta name="keywords" content="design pattern" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">设计模式</h1>
<div id="table-of-contents">
<h2>&#30446;&#24405;</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgb1ad09e">1. OO 基本原则</a></li>
<li><a href="#org0281889">2. 策略模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">行为型</span>&#xa0;<span class="__">对象</span></span></a></li>
<li><a href="#org56dd885">3. 状态模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">行为型</span>&#xa0;<span class="__">对象</span></span></a></li>
<li><a href="#org79b4fe3">4. 观察者模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">行为型</span>&#xa0;<span class="__">对象</span></span></a></li>
<li><a href="#org8f52336">5. 模板方法&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">行为型</span>&#xa0;<span class="_">类</span></span></a></li>
<li><a href="#orga6f050b">6. 装饰者模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">行为型</span>&#xa0;<span class="__">对象</span></span></a></li>
<li><a href="#org32fa240">7. 单件模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">创建型</span>&#xa0;<span class="__">对象</span></span></a></li>
<li><a href="#org832ab7a">8. 工厂模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">创建型</span>&#xa0;<span class="__">对象</span></span></a></li>
<li><a href="#orgc99af9a">9. 命令模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">行为型</span>&#xa0;<span class="__">对象</span></span></a></li>
<li><a href="#orgfb9f23e">10. 适配器模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="_">类</span>&#xa0;<span class="__">对象</span>&#xa0;<span class="___">结构型</span></span></a></li>
<li><a href="#org9770a56">11. 代理模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="__">对象</span>&#xa0;<span class="___">结构型</span></span></a></li>
<li><a href="#orgdefe5f1">12. 外观模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="__">对象</span>&#xa0;<span class="___">结构型</span></span></a></li>
<li><a href="#orgd412874">13. 迭代器模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="__">对象</span>&#xa0;<span class="___">结构型</span></span></a></li>
<li><a href="#org36339ac">14. 桥接模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="__">对象</span>&#xa0;<span class="___">结构型</span></span></a></li>
<li><a href="#org62ad1b9">15. 生成器模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">创建型</span>&#xa0;<span class="__">对象</span></span></a></li>
<li><a href="#orgb4cfee1">16. 组合模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">结构型</span>&#xa0;<span class="__">对象</span></span></a></li>
<li><a href="#org8fb2506">17. 责任链模式</a></li>
<li><a href="#org684a0c9">18. 一些 OO 提示</a></li>
</ul>
</div>
</div>
<div id="outline-container-orgb1ad09e" class="outline-2">
<h2 id="orgb1ad09e"><span class="section-number-2">1</span> OO 基本原则</h2>
<div class="outline-text-2" id="text-1">
<p>
S.O.L.I.D
</p>

<ul class="org-ul">
<li>单一职责原则</li>
<li>开放封闭原则</li>
<li>子类替换原则</li>
<li>接口隔离原则</li>
<li>依赖倒置原则</li>
</ul>
</div>
</div>

<div id="outline-container-org0281889" class="outline-2">
<h2 id="org0281889"><span class="section-number-2">2</span> 策略模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">行为型</span>&#xa0;<span class="__">对象</span></span></h2>
<div class="outline-text-2" id="text-2">
<p>
<a id="org59d807b"></a>
</p>
</div>
<div id="outline-container-org3a0de03" class="outline-3">
<h3 id="org3a0de03"><span class="section-number-3">2.1</span> 概述</h3>
<div class="outline-text-3" id="text-2-1">
<p>
定义一系列算法，分别封装起来，使它们之间可以相互替换。
</p>
</div>
</div>

<div id="outline-container-orgc2e62f2" class="outline-3">
<h3 id="orgc2e62f2"><span class="section-number-3">2.2</span> 适用性</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>一些 <b>相关</b> 的类接口一致，仅仅是行为有异</li>
<li>使算法使用的数据结构不暴露于客户</li>
<li>一个类定义了多种行为，且这些行为在类中是以多个条件语句的形式出现的</li>
</ul>
</div>
</div>

<div id="outline-container-orgd94a394" class="outline-3">
<h3 id="orgd94a394"><span class="section-number-3">2.3</span> 结构</h3>
<div class="outline-text-3" id="text-2-3">

<div class="figure">
<p><img src="../resources/OO/Strategy.png" alt="Strategy.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org56877b0" class="outline-3">
<h3 id="org56877b0"><span class="section-number-3">2.4</span> 角色</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li><p>
Context
</p>
<p class="verse">
维护一个 Strategy 对象的引用<br />
可开放接口，让 Strategy 访问其数据<br />
</p></li>
</ul>
</div>
</div>

<div id="outline-container-orgc32685c" class="outline-3">
<h3 id="orgc32685c"><span class="section-number-3">2.5</span> 优点</h3>
<div class="outline-text-3" id="text-2-5">
<ul class="org-ul">
<li>定义一组可供重用的算法（共通内容可放置于基类）</li>
<li>替代继承使用组合，更灵活，不用硬编码至 Context 中</li>
<li>消除条件语句</li>
<li>客户代码可以动态的选择具体算法</li>
</ul>
</div>
</div>

<div id="outline-container-orgcc3076f" class="outline-3">
<h3 id="orgcc3076f"><span class="section-number-3">2.6</span> 缺点</h3>
<div class="outline-text-3" id="text-2-6">
<ul class="org-ul">
<li><p>
客户代码必须了解到具体算法之间的区别（增加耦合）
</p>

<p>
Gof 建议：仅当不同行为是与客户相关的行为有关时，才使用 Strategy 模式
</p></li>

<li><p>
Strategy 和 Context 之间的通信开销
</p>

<p>
各具体算法所需要的参数不一样，但是接口共享。导致需要额外增加两边接口，导致这两个类更紧密的耦合
</p></li>

<li><p>
增加了对象的数目
</p>

<p>
参考 Flyweight 模式
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org3dc4356" class="outline-3">
<h3 id="org3dc4356"><span class="section-number-3">2.7</span> 实现</h3>
<div class="outline-text-3" id="text-2-7">
</div>
<div id="outline-container-org7f0668e" class="outline-4">
<h4 id="org7f0668e"><span class="section-number-4">2.7.1</span> 需定义 Context 和 Strategy 之间数据交换的接口</h4>
<div class="outline-text-4" id="text-2-7-1">
<ul class="org-ul">
<li><p>
方法一 Push：将数据作为参数放在 Strategy 的接口 AlgorithmInterface()中。
</p>

<p>
缺点：Context 可能发送一些 Strategy 不需要的数据。
</p></li>

<li><p>
方法二 Pull：Context 将自身作为参数传递给 Strategy，Strategy 再调用 Get 获取数据。
</p>

<p>
缺点：Context 必须为 Strategy 定义一堆更精细的 Get 接口。（C++中可使用友元）
</p></li>
</ul>
</div>
</div>

<div id="outline-container-orge8bccbf" class="outline-4">
<h4 id="orge8bccbf"><span class="section-number-4">2.7.2</span> 将 Strategy 作为 C++模板参数</h4>
<div class="outline-text-4" id="text-2-7-2">
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #3a81c3; font-weight: bold;">template</span> &lt;<span style="color: #3a81c3; font-weight: bold;">typename</span> <span style="color: #ba2f59; font-weight: bold;">Strategy</span>&gt;
<span style="color: #3a81c3; font-weight: bold;">class</span> <span style="color: #ba2f59; font-weight: bold;">Context</span>
{
<span style="color: #3a81c3; font-weight: bold;">private</span>:
    <span style="color: #ba2f59; font-weight: bold;">Strategy</span> <span style="color: #715ab1;">theStrategy</span>;
<span style="color: #3a81c3; font-weight: bold;">public</span>:
    <span style="color: #ba2f59; font-weight: bold;">void</span> <span style="color: #6c3163; font-weight: bold;">ContextInterface</span>() {theStrategy.AlgorithmInterface()}
};
</pre>
</div>
<ul class="org-ul">
<li>不再需要 Strategy 抽象基类。</li>
<li>避免多态，使用模板在编译时就绑定 Strategy 和 Context，提高运行效率，牺牲了动态绑定的灵活性。</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org6f9728e" class="outline-3">
<h3 id="org6f9728e"><span class="section-number-3">2.8</span> 相关模式</h3>
<div class="outline-text-3" id="text-2-8">
<p>
<a href="#org715992b">State</a> <a href="#org14b90de">两者区别</a>、<a href="#orge80f97d">Template Method</a>
</p>
</div>
</div>
</div>
<div id="outline-container-org56dd885" class="outline-2">
<h2 id="org56dd885"><span class="section-number-2">3</span> 状态模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">行为型</span>&#xa0;<span class="__">对象</span></span></h2>
<div class="outline-text-2" id="text-3">
<p>
<a id="org715992b"></a>
</p>
</div>
<div id="outline-container-org676fb56" class="outline-3">
<h3 id="org676fb56"><span class="section-number-3">3.1</span> 概述</h3>
<div class="outline-text-3" id="text-3-1">
<p>
对象的行为随着内部状态的改变而改变。
</p>
</div>
</div>

<div id="outline-container-org9be48b3" class="outline-3">
<h3 id="org9be48b3"><span class="section-number-3">3.2</span> 适用性</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>一个对象的行为取决于它的状态，并且需要在 <b>运行时</b> 根据它的状态改变它的行为</li>
<li>大量的依赖于对象状态的分支 <b>条件语句</b> 是一个信号，通常可以用 State 模式进行改造。</li>
</ul>
</div>
</div>

<div id="outline-container-org9adf450" class="outline-3">
<h3 id="org9adf450"><span class="section-number-3">3.3</span> 结构</h3>
<div class="outline-text-3" id="text-3-3">

<div class="figure">
<p><img src="../resources/OO/State.png" alt="State.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgc4d270a" class="outline-3">
<h3 id="orgc4d270a"><span class="section-number-3">3.4</span> 优点</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>易扩展新的状态，只需定义新的子类</li>
<li><p>
State 对象可以被多个 Context 对象共享
</p>
<p class="verse">
条件：状态 <b>对象</b> 不能持有自己的状态实例。需要将状态实例指定到一个静态变量中(可用单件模式实现)<br />
<br />
如果状态需要利用 Context 中的数据或方法，可在 Handle()方法传入 Context 的引用。<br />
<br />
这种实现不再需要 State 类保存自身的引用，可实现没有内部状态只有行为的轻量级对象。<br />
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org6fa7e5e" class="outline-3">
<h3 id="org6fa7e5e"><span class="section-number-3">3.5</span> 实现</h3>
<div class="outline-text-3" id="text-3-5">
</div>
<div id="outline-container-orgdd571fc" class="outline-4">
<h4 id="orgdd571fc"><span class="section-number-4">3.5.1</span> 谁定义状态转换</h4>
<div class="outline-text-4" id="text-3-5-1">
<ol class="org-ol">
<li>可由 Context 全权负责状态转移</li>
<li><p>
通常由 State 具体类自身指定它们的后继状态更方便灵活
</p>
<p class="verse">
可以给 Context 增加一个接口，让 State 子类对象显式地设定 Context 的内部状态。<br />
由 State 子类来指定状态转移的缺点是，增加了子类之间的依赖。<br />
</p></li>
</ol>
</div>
</div>

<div id="outline-container-org8098778" class="outline-4">
<h4 id="org8098778"><span class="section-number-4">3.5.2</span> 可使用表驱动法</h4>
<div class="outline-text-4" id="text-3-5-2">
<ul class="org-ul">
<li>State 模式主要对状态相关的行为进行建模</li>
<li>而表驱动着重于定义状态的转换，通常表的 key 表示某一状态，Value 为它的后继状态。</li>
</ul>
</div>
</div>

<div id="outline-container-org320c206" class="outline-4">
<h4 id="org320c206"><span class="section-number-4">3.5.3</span> 创建和销毁 State 对象</h4>
<div class="outline-text-4" id="text-3-5-3">
</div>
<ul class="org-ul">
<li><a id="orgb0a776c"></a>面临权衡：(1)需要时创建；(2)提前创建所有的 State 子类对象<br />
<div class="outline-text-5" id="text-orgb0a776c">
<ol class="org-ol">
<li>将要进入的状态在运行时是不可知的，且上下文不经常改变状态时，选择(1)。</li>
<li>另外，当 State 对象存储大量的信息时，使用(1)。</li>
<li>当状态频繁变化时，第(2)种方法更好。Context 对象需保存所有 State 子类对象的引用(不宜扩展)。</li>
</ol>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-org33c87d5" class="outline-3">
<h3 id="org33c87d5"><span class="section-number-3">3.6</span> 相关模式</h3>
<div class="outline-text-3" id="text-3-6">
<p>
<a href="#org59d807b">Strategy</a>、<a href="#orge80f97d">Template Method</a>
</p>
</div>
<div id="outline-container-orgf916d72" class="outline-4">
<h4 id="orgf916d72"><span class="section-number-4">3.6.1</span> 与 Strategy 模式的区别</h4>
<div class="outline-text-4" id="text-3-6-1">
<p>
<a id="org14b90de"></a>
意图：
</p>
<ul class="org-ul">
<li>Strategy 定义的是一组平行的算法，这些算法有着共同的目标。</li>
<li>State 模式更关注根据内在状态的不同，执行不同的行为，这些行为可能目的完全不同。</li>
</ul>
<p>
客户角度：
</p>
<ul class="org-ul">
<li>State 模式：通常的用法，状态通常跟着 Context 的行为而改变，对客户来说状态转换规则是不可见的。</li>
<li>Strategy 模式：为了灵活，通常是由客户来指定具体的策略。</li>
</ul>
<p>
总结：
</p>
<ul class="org-ul">
<li>Strategy 模式提供了一个继承之外更具弹性的替换方案。</li>
<li>State 模式更多的用来避免 Context 中过多的分支语句。</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-org79b4fe3" class="outline-2">
<h2 id="org79b4fe3"><span class="section-number-2">4</span> 观察者模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">行为型</span>&#xa0;<span class="__">对象</span></span></h2>
<div class="outline-text-2" id="text-4">
<p>
<a id="org42e2307"></a>
</p>
</div>
<div id="outline-container-orga036fc3" class="outline-3">
<h3 id="orga036fc3"><span class="section-number-3">4.1</span> 概述</h3>
<div class="outline-text-3" id="text-4-1">
<p>
定义对象之间一对多的依赖，当一个对象状态发生变化时，所有依赖于它的对象都得到通知。
</p>
</div>
</div>

<div id="outline-container-org8bd1b28" class="outline-3">
<h3 id="org8bd1b28"><span class="section-number-3">4.2</span> 结构</h3>
<div class="outline-text-3" id="text-4-2">

<div class="figure">
<p><img src="../resources/OO/Observer.png" alt="Observer.png" />
</p>
</div>

<p>
当一个观察者接收到改变指示后，流程图如下所示：
</p>


<div class="figure">
<p><img src="../resources/OO/ObserverSeq.png" alt="ObserverSeq.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgaabf583" class="outline-3">
<h3 id="orgaabf583"><span class="section-number-3">4.3</span> 优点</h3>
<div class="outline-text-3" id="text-4-3">
<ul class="org-ul">
<li><p>
Subject 和 Observer 间是抽象耦合
</p>
<p class="verse">
因为是非紧密耦合，Subject 和 Observer 可以来自于系统中的不同的抽象层次<br />
低层次 Subject 一样可以通知高层次 Observer，使用该模式不会破坏系统层次<br />
这就是抽象 Subject 和 Observer 的作用。<br />
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org3d51d0b" class="outline-3">
<h3 id="org3d51d0b"><span class="section-number-3">4.4</span> 缺点</h3>
<div class="outline-text-3" id="text-4-4">
<ul class="org-ul">
<li><p>
来自某一观察者的意外更新
</p>
<p class="verse">
某个观察者更新了主题的状态，导致其他观察者也发生了改变。<br />
如果更新准则定义或维护不当，常常会引起错误的更新。<br />
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org8fa79b9" class="outline-3">
<h3 id="org8fa79b9"><span class="section-number-3">4.5</span> 实现</h3>
<div class="outline-text-3" id="text-4-5">
</div>
<div id="outline-container-org1297c86" class="outline-4">
<h4 id="org1297c86"><span class="section-number-4">4.5.1</span> 主题与观察者的关联方式</h4>
<div class="outline-text-4" id="text-4-5-1">
<ul class="org-ul">
<li>主题跟踪观察者最简单的方式是保存观察者们的引用</li>
<li>另一种方式是维护一份主题与观察者之间的映射表</li>
</ul>
</div>
</div>

<div id="outline-container-org35f8157" class="outline-4">
<h4 id="org35f8157"><span class="section-number-4">4.5.2</span> 观察多个主题</h4>
<div class="outline-text-4" id="text-4-5-2">
<p class="verse">
某些情况下，观察多个主题是有意义的，例如：一个表格对象依赖于多个数据源。<br />
需要扩展 Update 接口使观察者知道是哪一个主题送来的。<br />
主题可以简单的将自己作为观察者 Update 接口的参数，让观察者知道应去检查哪一个目标。<br />
</p>
</div>
</div>

<div id="outline-container-org4d24e14" class="outline-4">
<h4 id="org4d24e14"><span class="section-number-4">4.5.3</span> 谁触发更新</h4>
<div class="outline-text-4" id="text-4-5-3">
<p>
Notify 谁来调用？
</p>

<ul class="org-ul">
<li>由主题对象的状态设定操作自动调用。
<ul class="org-ul">
<li>优点：客户不需要调用 Notify。</li>
<li>缺点：多个连续的设定操作会产生多次连续更新，可能效率较低。(关键还是要看需求：在更新状态的时候是否需要通知)</li>
</ul></li>

<li>客户负责调用 Notify
<ul class="org-ul">
<li>优点：客户可以在一系列状态设定操作之后一次性通知更新。</li>
<li>缺点：给客户增加了触发更新的责任。客户忘记的话，容易出错。</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgf9f64e1" class="outline-4">
<h4 id="orgf9f64e1"><span class="section-number-4">4.5.4</span> 主题删除时，应通知观察者置空主题引用</h4>
</div>

<div id="outline-container-orgeecce46" class="outline-4">
<h4 id="orgeecce46"><span class="section-number-4">4.5.5</span> 在发出通知前，确保主题的状态自身是一致的</h4>
<div class="outline-text-4" id="text-4-5-5">
<p>
反例如下：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #ba2f59; font-weight: bold;">void</span> <span style="color: #4e3163;">MySubject</span>::<span style="color: #6c3163; font-weight: bold;">Operation</span> (<span style="color: #ba2f59; font-weight: bold;">int</span> <span style="color: #715ab1;">newValue</span>)
{
  <span style="color: #4e3163;">BaseClassSubject</span>::Operation(newValue);<span style="color: #2aa1ae; background-color: #ecf3ec;">//</span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#20808;&#35302;&#21457;&#20102;&#36890;&#30693;</span>
  _myInstVar += newValue;<span style="color: #2aa1ae; background-color: #ecf3ec;">//</span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#21518;&#20462;&#25913;&#33258;&#36523;&#29366;&#24577;</span>
}
</pre>
</div>
<p>
可以使用<a href="#orge80f97d">模板方法</a>发送通知来避免这种错误。(模板方法规定好修改状态和触发通知的顺序)
</p>
</div>
</div>

<div id="outline-container-org180c131" class="outline-4">
<h4 id="org180c131"><span class="section-number-4">4.5.6</span> 推拉模型的取舍</h4>
<div class="outline-text-4" id="text-4-5-6">
<ul class="org-ul">
<li>推模型(大多数情况使用它)
<ul class="org-ul">
<li>Update 参数传入的信息可能有很多，并非是所有观察者都需要的。</li>
<li>主题对观察者所需要的信息的假定并不总是正确。</li>
</ul></li>

<li>拉模型
<ul class="org-ul">
<li>Update 传入主题的引用。</li>
<li>观察者自己向主题获取信息。</li>
<li>缺点：可能需要调用多个接口以搜集全观察者自己需要的状态。(耦合度增加)</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgf43ecd2" class="outline-4">
<h4 id="orgf43ecd2"><span class="section-number-4">4.5.7</span> 只关注感兴趣的改变</h4>
<div class="outline-text-4" id="text-4-5-7">
<p>
扩展主题的注册接口，加入 interest 参数
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #2aa1ae; background-color: #ecf3ec;">//</span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#20027;&#39064;</span>
<span style="color: #ba2f59; font-weight: bold;">void</span> <span style="color: #4e3163;">Subject</span>::<span style="color: #6c3163; font-weight: bold;">Attach</span>(<span style="color: #ba2f59; font-weight: bold;">Observer</span>*, <span style="color: #ba2f59; font-weight: bold;">Aspect</span>&amp; <span style="color: #715ab1;">interest</span>);
<span style="color: #2aa1ae; background-color: #ecf3ec;">//</span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#35266;&#23519;&#32773;</span>
<span style="color: #ba2f59; font-weight: bold;">void</span> <span style="color: #4e3163;">Observer</span>::<span style="color: #6c3163; font-weight: bold;">Update</span>(<span style="color: #ba2f59; font-weight: bold;">Subject</span>*, <span style="color: #ba2f59; font-weight: bold;">Aspect</span>&amp; <span style="color: #715ab1;">interest</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-org7fbd2b7" class="outline-4">
<h4 id="org7fbd2b7"><span class="section-number-4">4.5.8</span> 封装复杂的更新语义(ChangeManager)</h4>
<div class="outline-text-4" id="text-4-5-8">
<p class="verse">
当主题与观察者之间的依赖关系特别复杂时，<br />
需要一个 ChangeManager 对象来维护这些关系。<br />
<br />
目的：尽量减少观察者反映其主题的状态变化所需的工作量。<br />
例子：如果一操作涉及到几个主题，就必须保证所有的主题都更改完了，再<br />
一并通知它们的观察者。<br />
</p>

<p>
该对象主要有 <b>三个职责</b> ：
</p>
<ul class="org-ul">
<li>管理主题与观察者之间的映射表，提供接口来维护这个映射表。</li>
<li>定义一个特定的更新策略。</li>
<li>根据一个主题的请求，更新所有它的观察者。</li>
</ul>
<p>
详细参考：<a href="#org61086f6">基于 ChangeManager 的 Observer 模式</a>
</p>
</div>
</div>
</div>

<div id="outline-container-org144198d" class="outline-3">
<h3 id="org144198d"><span class="section-number-3">4.6</span> 扩展</h3>
<div class="outline-text-3" id="text-4-6">
<p>
<a id="org61086f6"></a>
基于 ChangeManager 的 Observer 模式
</p>

<div class="figure">
<p><img src="../resources/OO/ObserverWithChangeManager.png" alt="ObserverWithChangeManager.png" />
</p>
</div>

<p>
具体更新策略由具体的 ChangeManager 来决定：
</p>
<ul class="org-ul">
<li>SimpleChangeManager 总是更新每一个主题的所有观察者</li>
<li>DAGChangeManager 实现多个主题变更时，只更新观察者一次</li>
</ul>
</div>
</div>

<div id="outline-container-orgbe0cafb" class="outline-3">
<h3 id="orgbe0cafb"><span class="section-number-3">4.7</span> 相关模式</h3>
<div class="outline-text-3" id="text-4-7">
<ul class="org-ul">
<li>ChangeManager 是一个 Mediator 模式的实例</li>
<li>ChangeManager 通常是 Singleton 模式</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org8f52336" class="outline-2">
<h2 id="org8f52336"><span class="section-number-2">5</span> 模板方法&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">行为型</span>&#xa0;<span class="_">类</span></span></h2>
<div class="outline-text-2" id="text-5">
<p>
<a id="orge80f97d"></a>
</p>
</div>
<div id="outline-container-orgd3ade83" class="outline-3">
<h3 id="orgd3ade83"><span class="section-number-3">5.1</span> 概述</h3>
<div class="outline-text-3" id="text-5-1">
<p class="verse">
最基本的设计模式，代码复用的基本技术<br />
定义一系列算法的骨架，将其中的一些步骤延迟到子类中。<br />
使子类可以不改变一个算法的结构，而重定义算法的某些特定步骤。<br />
</p>
</div>
</div>
<div id="outline-container-org3cca5f1" class="outline-3">
<h3 id="org3cca5f1"><span class="section-number-3">5.2</span> 适用性</h3>
<div class="outline-text-3" id="text-5-2">
<ul class="org-ul">
<li>多个子类中存在一些公共行为，需要提取出来，做法如下：
<ol class="org-ol">
<li>识别代码中不同部分</li>
<li>提取出新的函数</li>
<li>用一个新的模板方法替换原算法(公共部分放于其中)</li>
</ol></li>
<li>控制子类扩展，模板方法只在特定点调用子类方法</li>
</ul>
</div>
</div>
<div id="outline-container-org0b8ecf7" class="outline-3">
<h3 id="org0b8ecf7"><span class="section-number-3">5.3</span> 结构</h3>
<div class="outline-text-3" id="text-5-3">

<div class="figure">
<p><img src="../resources/OO/TemplateMethod.png" alt="TemplateMethod.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org9522cc5" class="outline-3">
<h3 id="org9522cc5"><span class="section-number-3">5.4</span> 优点</h3>
<div class="outline-text-3" id="text-5-4">
<ul class="org-ul">
<li><p>
提供了反向的控制结构。即"好莱坞法则"："别找我们，我们找你。"。
</p>
<p class="verse">
即高层组件调用低层组件，低层组件不能调用高层组件。<br />
但并非低层组件一定不能调用高层组件，最重要的是避免让<br />
高层组件和低层组件之间有明显的环状依赖。<br />
</p></li>
<li>一个模板方法整合了一系列操作，从而减少了需要客户程序调用的接口数。</li>
<li>客户代码只依赖于模板方法基类，不依赖于具体类，减少整个系统的 <b>依赖</b> 。</li>
</ul>
</div>
</div>

<div id="outline-container-orgbf97dc0" class="outline-3">
<h3 id="orgbf97dc0"><span class="section-number-3">5.5</span> 实现</h3>
<div class="outline-text-3" id="text-5-5">
<ul class="org-ul">
<li><p>
hook operations
提供缺省<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>的行为，子类在必要时拓展。例如：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #ba2f59; font-weight: bold;">void</span> <span style="color: #4e3163;">AbstractClass</span>::<span style="color: #6c3163; font-weight: bold;">TemplateMethod</span>()
{
  Operation1();
  Operation2();
  Hook1();
  <span style="color: #3a81c3; font-weight: bold;">if</span> (HookFileExisted())
    {
      Operation3();
    }
}

<span style="color: #ba2f59; font-weight: bold;">bool</span> <span style="color: #4e3163;">AbstractClass</span>::<span style="color: #6c3163; font-weight: bold;">HookFileExisted</span>()
{
  <span style="color: #3a81c3; font-weight: bold;">return</span> <span style="color: #4e3163;">true</span>;
}
</pre>
</div>
<p class="verse">
<b>重要</b> ：模板方法应该指明哪些操作是钩子(可被重定义)，哪些操作是抽象操作(必须被重定义)。<br />
可以做一个命名约定<br />
需被重定义的操作加上前缀"Do"<br />
钩子方法加上前缀"Hook"<br />
</p></li>
</ul>
</div>
</div>

<div id="outline-container-orgfd67c34" class="outline-3">
<h3 id="orgfd67c34"><span class="section-number-3">5.6</span> 相关模式</h3>
<div class="outline-text-3" id="text-5-6">
<ul class="org-ul">
<li>Factory Method 常被模板方法调用。</li>
<li>Strategy 使用委托来改变整个算法，模板方法使用继承来改变算法的一部分。</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orga6f050b" class="outline-2">
<h2 id="orga6f050b"><span class="section-number-2">6</span> 装饰者模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">行为型</span>&#xa0;<span class="__">对象</span></span></h2>
<div class="outline-text-2" id="text-6">
<p>
<a id="orgf6c28a6"></a>
</p>
</div>
<div id="outline-container-orgd38cad2" class="outline-3">
<h3 id="orgd38cad2"><span class="section-number-3">6.1</span> 概述</h3>
<div class="outline-text-3" id="text-6-1">
<p>
动态地给一个对象添加一些额外的职责。提供了比继承更大的灵活<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>。
</p>
</div>
</div>

<div id="outline-container-orgba6dd8a" class="outline-3">
<h3 id="orgba6dd8a"><span class="section-number-3">6.2</span> 结构</h3>
<div class="outline-text-3" id="text-6-2">

<div class="figure">
<p><img src="../resources/OO/Decorator.png" alt="Decorator.png" />
</p>
</div>

<ul class="org-ul">
<li>使用继承的目的是为了达到类型匹配，使用户在使用 Decorator 对象时，与使用 Component 一样。</li>
</ul>
</div>
</div>

<div id="outline-container-orgc528414" class="outline-3">
<h3 id="orgc528414"><span class="section-number-3">6.3</span> 优点</h3>
<div class="outline-text-3" id="text-6-3">
<ul class="org-ul">
<li>比静态继承更灵活，在运行时添加职责。</li>
<li>继承在添加一些共通职责时，容易产生类爆炸。Decorator 添加的职责大多数情况下能重用。</li>
<li>使结构层次较高的类更简洁。不依赖于现有已扩展的 Decorator 类，定义新类型的 Decorator 很容易。</li>
</ul>
</div>
</div>

<div id="outline-container-org21bcaeb" class="outline-3">
<h3 id="org21bcaeb"><span class="section-number-3">6.4</span> 缺点</h3>
<div class="outline-text-3" id="text-6-4">
<ul class="org-ul">
<li>使用装饰时不应该依赖于对象标识。被装饰了的组件与这个组件本身就对象标识而言，是有区别的。</li>
<li>产生很多小对象。对于不了解系统的人，难以学习，排错也比较困难。</li>
</ul>
</div>
</div>

<div id="outline-container-org13b5fe2" class="outline-3">
<h3 id="org13b5fe2"><span class="section-number-3">6.5</span> 实现</h3>
<div class="outline-text-3" id="text-6-5">
<ol class="org-ol">
<li>接口一致性。所有的 Component 和 Decorator 必须有一个公共的父类。</li>
<li>抽象的 Decorator 基类是可选的。仅需添加一个职责时，无需 Decorator 基类。</li>
<li>保持 Component 类的简单性。公共父类仅定义接口，尽量避免加入子类并不需要的职责。</li>
</ol>
</div>
</div>

<div id="outline-container-org410513b" class="outline-3">
<h3 id="org410513b"><span class="section-number-3">6.6</span> 相关模式</h3>
<div class="outline-text-3" id="text-6-6">
</div>
<div id="outline-container-orgb7c10c7" class="outline-4">
<h4 id="orgb7c10c7"><span class="section-number-4">6.6.1</span> 与 Strategy 的比较：</h4>
<div class="outline-text-4" id="text-6-6-1">
<ul class="org-ul">
<li>Decorator 可看做一个对象的 <b>外壳</b> 。</li>
<li><p>
Strategy 则是改变对象的内核。
</p>
<p class="verse">
当 Component 基类很 <b>庞大</b> 时，使用 Decorator 代价太高，Strategy 模式更好一些。<br />
比如，绘制边框的职责，既可以使用 Decorator 模式包一层外壳，<br />
也可以使用 Border 对象专门负责，再组合进 Context。<br />
</p></li>
</ul>
</div>
</div>

<div id="outline-container-orgaa76588" class="outline-4">
<h4 id="orgaa76588"><span class="section-number-4">6.6.2</span> Composite 模式</h4>
<div class="outline-text-4" id="text-6-6-2">
<p class="verse">
可以将装饰视为一个退化的、仅有一个组件的组合。<br />
另外，它的目的在于添加职责，而 Composite 目的在于对象聚合。<br />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org32fa240" class="outline-2">
<h2 id="org32fa240"><span class="section-number-2">7</span> 单件模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">创建型</span>&#xa0;<span class="__">对象</span></span></h2>
<div class="outline-text-2" id="text-7">
<p>
<a id="org107c590"></a>
</p>
</div>
<div id="outline-container-org2d2a137" class="outline-3">
<h3 id="org2d2a137"><span class="section-number-3">7.1</span> 概述</h3>
<div class="outline-text-3" id="text-7-1">
<p>
保证类仅有一个实例，并提供该实例的全局访问点。
</p>
</div>
</div>
<div id="outline-container-orgf345da5" class="outline-3">
<h3 id="orgf345da5"><span class="section-number-3">7.2</span> 适用性</h3>
<div class="outline-text-3" id="text-7-2">
<ul class="org-ul">
<li>当类只能有一个实例</li>
<li>当这个唯一实例需要通过子类化扩展</li>
</ul>
</div>
</div>
<div id="outline-container-orga114803" class="outline-3">
<h3 id="orga114803"><span class="section-number-3">7.3</span> 结构</h3>
<div class="outline-text-3" id="text-7-3">

<div class="figure">
<p><img src="../resources/OO/Singleton.png" alt="Singleton.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org4ae3eb3" class="outline-3">
<h3 id="org4ae3eb3"><span class="section-number-3">7.4</span> 优点</h3>
<div class="outline-text-3" id="text-7-4">
<ul class="org-ul">
<li><b>受控访问</b></li>
<li><p>
起到命名空间的作用
</p>
<p class="verse">
对全局变量的一种改进，全局变量会污染名空间(容易重名)。<br />
支持静态类的语言，使用静态类解决该问题更简单。<br />
</p></li>
</ul>


<ul class="org-ul">
<li>可以被 <b>继承</b> 扩展。</li>
<li><p>
可扩展单例为 <b>多个实例</b>
</p>

<p>
允许 Singleton 类可以管理多个实例（池类技术）。
</p></li>
</ul>
</div>
</div>

<div id="outline-container-orgd2da6ff" class="outline-3">
<h3 id="orgd2da6ff"><span class="section-number-3">7.5</span> 实现</h3>
<div class="outline-text-3" id="text-7-5">
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #3a81c3; font-weight: bold;">class</span> <span style="color: #ba2f59; font-weight: bold;">Singleton</span>
{
<span style="color: #3a81c3; font-weight: bold;">public</span>:
    <span style="color: #3a81c3; font-weight: bold;">static</span> <span style="color: #ba2f59; font-weight: bold;">Singleton</span>* <span style="color: #6c3163; font-weight: bold;">GetInstance</span>();
<span style="color: #3a81c3; font-weight: bold;">protected</span>:
    <span style="color: #6c3163; font-weight: bold;">Singleton</span>() : _instance(<span style="color: #4e3163;">NULL</span>);<span style="color: #2aa1ae; background-color: #ecf3ec;">//</span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#38544;&#34255;&#30340;&#26500;&#36896;&#20989;&#25968;</span>
<span style="color: #3a81c3; font-weight: bold;">private</span>:
    <span style="color: #3a81c3; font-weight: bold;">static</span> <span style="color: #ba2f59; font-weight: bold;">Singleton</span>* <span style="color: #715ab1;">_instance</span>;
};

<span style="color: #ba2f59; font-weight: bold;">Singleton</span>* <span style="color: #4e3163;">Singleton</span>::<span style="color: #6c3163; font-weight: bold;">GetInstance</span> ()
{
    <span style="color: #3a81c3; font-weight: bold;">if</span> (_instance == <span style="color: #4e3163;">NULL</span>) _instance = <span style="color: #3a81c3; font-weight: bold;">new</span> <span style="color: #ba2f59; font-weight: bold;">Singleton</span>;
    <span style="color: #3a81c3; font-weight: bold;">return</span> _instance;
}
</pre>
</div>
</div>
<div id="outline-container-orgf4d4680" class="outline-4">
<h4 id="orgf4d4680"><span class="section-number-4">7.5.1</span> 同步问题</h4>
<div class="outline-text-4" id="text-7-5-1">
<p class="verse">
为了保证在多线程环境下只创建一个实例，需要对 GetInstance 方法做同步处理。<br />
<br />
简单的方法：直接将 GetInstance 方法声明为 synchronized。<br />
<br />
这样的做法有个问题：<br />
我们需要同步的只是 GetInstance 内部负责创建实例的区块，<br />
对整个函数进行同步，如果函数体内内容较多且外部调用很频繁，<br />
开销会很大。<br />
<br />
应该只同步创建实例的区块(java 示例)：<br />
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #3a81c3; font-weight: bold;">public</span> <span style="color: #3a81c3; font-weight: bold;">class</span> <span style="color: #ba2f59; font-weight: bold;">Singleton</span>
{
    <span style="color: #3a81c3; font-weight: bold;">private</span> <span style="color: #3a81c3; font-weight: bold;">static</span> <span style="color: #ba2f59; font-weight: bold;">Singleton</span> <span style="color: #715ab1;">uniqueInstance</span>;
    <span style="color: #3a81c3; font-weight: bold;">private</span> <span style="color: #6c3163; font-weight: bold;">Singleton</span>() {}
    <span style="color: #3a81c3; font-weight: bold;">public</span> <span style="color: #3a81c3; font-weight: bold;">static</span> <span style="color: #ba2f59; font-weight: bold;">Singleton</span> <span style="color: #6c3163; font-weight: bold;">GetInstance</span>() {
        <span style="color: #3a81c3; font-weight: bold;">if</span> (uniqueInstance == <span style="color: #4e3163;">null</span>) { <span style="color: #2aa1ae; background-color: #ecf3ec;">//</span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#21028;&#26029;&#26159;&#21542;&#35201;&#36827;&#20837;&#36127;&#36131;&#21019;&#24314;&#23454;&#20363;&#30340;&#21516;&#27493;&#27169;&#22359;</span>
            <span style="color: #3a81c3; font-weight: bold;">synchronized</span> (Singleton.<span style="color: #3a81c3; font-weight: bold;">class</span>) {<span style="color: #2aa1ae; background-color: #ecf3ec;">//</span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#20165;&#19968;&#20010;&#32447;&#31243;&#25191;&#34892;&#27492;&#21306;&#22359;&#65292;&#30830;&#20445;&#21482;&#21019;&#24314;&#19968;&#20010;&#23454;&#20363;&#12290;</span>
                <span style="color: #3a81c3; font-weight: bold;">if</span> (uniqueInstance == <span style="color: #4e3163;">null</span>) {
                    uniqueInstance = <span style="color: #3a81c3; font-weight: bold;">new</span> <span style="color: #ba2f59; font-weight: bold;">Singleton</span>();<span style="color: #2aa1ae; background-color: #ecf3ec;">//</span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#23545;&#20110;&#21516;&#27493;&#25968;&#25454;&#65292;&#24403;&#20320;&#30340;&#20889;&#20837;&#20381;&#36182;&#20110;&#35835;&#21462;&#30340;&#20869;&#23481;&#30340;&#26102;&#20505;&#65292;&#35201;</span><span style="color: #6c4173; background-color: #ecf3ec;">&#23567;&#24515;&#12290;</span>
                }
            }
        }
        <span style="color: #3a81c3; font-weight: bold;">return</span> uniqueInstance;
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc7bcf0e" class="outline-4">
<h4 id="orgc7bcf0e"><span class="section-number-4">7.5.2</span> 继承问题</h4>
<div class="outline-text-4" id="text-7-5-2">
<p>
问题：子类的单件实例化在何处实现？
</p>

<ul class="org-ul">
<li><p>
在父类的 GetInstance 中决定使用哪一个单件子类。
</p>
<p class="verse">
可以传入参数，使用条件语句在运行时期选择适合的子类。<br />
局限在于硬性限定了可能的 Singleton 子类的集合。<br />
优点：支持多态，运行时指定子类。<br />
</p></li>

<li><p>
将 GetInstance 类从父类中剥出，并将它放入子类。
</p>
<p class="verse">
客户代码通过类名调用 GetInstance 自行决定使用哪个子类。<br />
编译时决定使用哪个子类，非运行时，不够灵活。<br />
</p></li>

<li><p>
使用设定文件(或注册表等)记录单件类。
</p>

<p>
GetInstance()读取相关配置项，通过映射表找到相对应的单件类。
</p></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org391ec55" class="outline-3">
<h3 id="org391ec55"><span class="section-number-3">7.6</span> 与静态类比较</h3>
<div class="outline-text-3" id="text-7-6">
</div>
<div id="outline-container-org304551e" class="outline-4">
<h4 id="org304551e"><span class="section-number-4">7.6.1</span> 概念上的理解</h4>
<div class="outline-text-4" id="text-7-6-1">
<p>
静态类是单件模式的一种特殊实现方式。
</p>
<ul class="org-ul">
<li>静态类更多的用于与特定实例无关的 <b>全局</b> 属性和 <b>全局</b> 方法的分类(起到命名空间的作用)。</li>
<li>而单件的概念是确实需要一个实例，而且实例只能有一个。比如：注册表对象，线程池对象。</li>
</ul>
</div>
</div>

<div id="outline-container-orgbea26b5" class="outline-4">
<h4 id="orgbea26b5"><span class="section-number-4">7.6.2</span> 创建的时间</h4>
<div class="outline-text-4" id="text-7-6-2">
<ul class="org-ul">
<li>静态类在编译时创建</li>
<li>单件模式的类在运行时创建(创建的时机在一定程度上可选)</li>
</ul>
</div>
</div>

<div id="outline-container-org766e41a" class="outline-4">
<h4 id="org766e41a"><span class="section-number-4">7.6.3</span> 扩展性</h4>
<div class="outline-text-4" id="text-7-6-3">
<ul class="org-ul">
<li>静态类不能被继承，也无法继承其他类。(如果该类需要实现一些接口，则不能使用静态类)</li>
<li>单件类可以被继承扩展</li>
<li>如需要从一个实例变为多个实例，静态类做不到。单件类可以扩展满足要求 <b>更灵活</b></li>
</ul>
</div>
</div>

<div id="outline-container-orgc749146" class="outline-4">
<h4 id="orgc749146"><span class="section-number-4">7.6.4</span> 总结</h4>
<div class="outline-text-4" id="text-7-6-4">
<ul class="org-ul">
<li>静态类更多地用于对全局方法、全局变量的分类组织。</li>
<li>单件模式表示有且仅有一个对象。单件类可以被继承，易于扩展。</li>
</ul>

<p class="verse">
当对于是否使用单件模式没把握的时候，使用单件类更好一些。<br />
原因：静态类改成实例类，会改变接口，从而影响所有的客户代码。<br />
</p>
</div>
</div>
</div>

<div id="outline-container-org8b5e49a" class="outline-3">
<h3 id="org8b5e49a"><span class="section-number-3">7.7</span> 相关模式</h3>
<div class="outline-text-3" id="text-7-7">
<p>
经常使用 Singleton 模式的其他模式：
</p>
<ul class="org-ul">
<li><a href="#org5c088ad">Abstract Factory</a></li>
<li><a href="#org4080251">Builder</a></li>
<li>Prototype</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org832ab7a" class="outline-2">
<h2 id="org832ab7a"><span class="section-number-2">8</span> 工厂模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">创建型</span>&#xa0;<span class="__">对象</span></span></h2>
<div class="outline-text-2" id="text-8">
<p>
<a id="org340adb5"></a>
</p>
</div>
<div id="outline-container-org211e4a9" class="outline-3">
<h3 id="org211e4a9"><span class="section-number-3">8.1</span> 简单工厂方法</h3>
<div class="outline-text-3" id="text-8-1">
<p>
<a id="org579899f"></a>
</p>
</div>
<div id="outline-container-org514a353" class="outline-4">
<h4 id="org514a353"><span class="section-number-4">8.1.1</span> 结构</h4>
<div class="outline-text-4" id="text-8-1-1">

<div class="figure">
<p><img src="../resources/OO/SimpleFactory.png" alt="SimpleFactory.png" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org18957b2" class="outline-3">
<h3 id="org18957b2"><span class="section-number-3">8.2</span> 工厂方法</h3>
<div class="outline-text-3" id="text-8-2">
<p>
<a id="org3494a11"></a>
</p>
</div>
<div id="outline-container-org6b6b226" class="outline-4">
<h4 id="org6b6b226"><span class="section-number-4">8.2.1</span> 概述</h4>
<div class="outline-text-4" id="text-8-2-1">
<p>
定义一个用于创建对象的接口，让子类决定实例化哪个产品。
</p>
</div>
</div>

<div id="outline-container-orgfded538" class="outline-4">
<h4 id="orgfded538"><span class="section-number-4">8.2.2</span> 结构</h4>
<div class="outline-text-4" id="text-8-2-2">

<div class="figure">
<p><img src="../resources/OO/FactoryMethod.png" alt="FactoryMethod.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org4af9d7f" class="outline-4">
<h4 id="org4af9d7f"><span class="section-number-4">8.2.3</span> 实现</h4>
<div class="outline-text-4" id="text-8-2-3">
<ul class="org-ul">
<li><p>
避免子类化
</p>
<p class="verse">
工厂方法一个潜在的问题是它们可能仅为了创建适当的 Product 对象<br />
而迫使你创建 Creator 子类，C++中可以提供使用模板避免子类化。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #3a81c3; font-weight: bold;">class</span> <span style="color: #ba2f59; font-weight: bold;">Creator</span>
{
<span style="color: #3a81c3; font-weight: bold;">public</span>:
    <span style="color: #3a81c3; font-weight: bold;">virtual</span> <span style="color: #ba2f59; font-weight: bold;">Product</span>* <span style="color: #6c3163; font-weight: bold;">Create</span>() = 0;
};

<span style="color: #3a81c3; font-weight: bold;">template</span> &lt;<span style="color: #3a81c3; font-weight: bold;">class</span> <span style="color: #ba2f59; font-weight: bold;">T</span>&gt;
<span style="color: #3a81c3; font-weight: bold;">class</span> <span style="color: #ba2f59; font-weight: bold;">StandardCreator</span> : <span style="color: #3a81c3; font-weight: bold;">public</span> <span style="color: #ba2f59; font-weight: bold;">Creator</span>
{
<span style="color: #3a81c3; font-weight: bold;">public</span>:
    <span style="color: #3a81c3; font-weight: bold;">virtual</span> <span style="color: #ba2f59; font-weight: bold;">Product</span>* <span style="color: #6c3163; font-weight: bold;">Create</span>();
};

<span style="color: #3a81c3; font-weight: bold;">template</span> &lt;<span style="color: #3a81c3; font-weight: bold;">class</span> <span style="color: #ba2f59; font-weight: bold;">T</span>&gt;
<span style="color: #ba2f59; font-weight: bold;">Product</span>* <span style="color: #4e3163;">StandardCreator</span>&lt;<span style="color: #ba2f59; font-weight: bold;">T</span>&gt;::<span style="color: #6c3163; font-weight: bold;">Create</span>()
{
    <span style="color: #3a81c3; font-weight: bold;">return</span> <span style="color: #3a81c3; font-weight: bold;">new</span> <span style="color: #ba2f59; font-weight: bold;">T</span>;
}
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-org2a191aa" class="outline-4">
<h4 id="org2a191aa"><span class="section-number-4">8.2.4</span> 相关模式</h4>
<div class="outline-text-4" id="text-8-2-4">
<ul class="org-ul">
<li>Abstract Factory 经常使用工厂方法来实现。</li>
<li><p>
工厂方法通常在 Template Method 中被调用。
</p>

<p>
模板方法指定一系列的具体步骤，而创建对象的一步委托给工厂方法。
</p></li>

<li><p>
Prototype 不需要创建 Creator 的子类。
</p>

<p>
但会要求一个针对 Product 类的 Initialize 操作。Creator 使用 Initialize 来初始化对象。
</p></li>

<li><p>
与简单工厂方法的比较
</p>
<p class="verse">
简单工厂在 SimpleFactory 的 create 方法中，使用类似 Switch 语句来根据参数制造产品。<br />
缺点在于，switch 不容易扩展，并且 SimpleFactory 需要知道所有的产品类，耦合紧密。<br />
</p></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org85249be" class="outline-3">
<h3 id="org85249be"><span class="section-number-3">8.3</span> 抽象工厂</h3>
<div class="outline-text-3" id="text-8-3">
<p>
<a id="org5c088ad"></a>
</p>
</div>
<div id="outline-container-org8dd7523" class="outline-4">
<h4 id="org8dd7523"><span class="section-number-4">8.3.1</span> 概述</h4>
<div class="outline-text-4" id="text-8-3-1">
<p>
提供创建一系列产品族的接口，而无需指定各产品的具体类。
</p>
</div>
</div>

<div id="outline-container-org51ebeae" class="outline-4">
<h4 id="org51ebeae"><span class="section-number-4">8.3.2</span> 角色</h4>
<div class="outline-text-4" id="text-8-3-2">
<ul class="org-ul">
<li><p>
ConcreteFactory
</p>

<p>
负责创建各产品对象，每一个具体工厂类都代表一种产品之间的组合。
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org789c80e" class="outline-4">
<h4 id="org789c80e"><span class="section-number-4">8.3.3</span> 结构</h4>
<div class="outline-text-4" id="text-8-3-3">

<div class="figure">
<p><img src="../resources/OO/AbstractFactory.png" alt="AbstractFactory.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org4b50120" class="outline-4">
<h4 id="org4b50120"><span class="section-number-4">8.3.4</span> 优点</h4>
<div class="outline-text-4" id="text-8-3-4">
<ul class="org-ul">
<li><p>
<b>使得易于交换产品系列</b>
</p>

<p>
通过替换具体的工厂类，来改变产品系列。
</p></li>

<li><p>
<b>有利于产品的一致性</b>
</p>

<p>
当一系列产品被设计成一起工作时，抽象工厂可以保证一个应用一次只能使用同一系列的对象。
</p></li>
</ul>
</div>
</div>

<div id="outline-container-orgdfede39" class="outline-4">
<h4 id="orgdfede39"><span class="section-number-4">8.3.5</span> 缺点</h4>
<div class="outline-text-4" id="text-8-3-5">
<ul class="org-ul">
<li><p>
<b>难以支持新种类的产品</b>
</p>
<p class="verse">
AbstractFactory 接口定义了可以被创建的产品集合。支持新的产品种类，<br />
就需要扩展接口，还涉及到所有子类的改变。<a href="#orgc03cb98">解决办法</a><br />
</p></li>
</ul>
</div>
</div>

<div id="outline-container-orgb9c7104" class="outline-4">
<h4 id="orgb9c7104"><span class="section-number-4">8.3.6</span> 实现</h4>
<div class="outline-text-4" id="text-8-3-6">
<ul class="org-ul">
<li><p>
将具体工厂作为单件
</p>

<p>
一般每个产品系列只需一个 ConcreteFactory 的实例。
</p></li>

<li><p>
创建产品。
</p>
<p class="verse">
AbstractFactory 只声明创建产品的接口。<br />
如果有多个可能的产品系列，具体工厂也可以使用 Prototype 模式来实现。<br />
具体工厂使用产品系列中每一个产品的原型实例来初始化，<br />
且它通过复制它的原型来创建新的产品。<br />
<br />
基于原型的好处：不是每个新的产品系列都需要一个新的具体工厂类。<br />
</p></li>
</ul>

<p>
<a id="orgc03cb98"></a>
</p>
<ul class="org-ul">
<li><p>
定义可扩展的工厂
</p>
<p class="verse">
加入新产品需要扩展接口，影响子类。<br />
一个更灵活但不太安全的设计是给创建对象的操作增加一个参数。<br />
AbstractFactory 只提供一个 Create 操作，用参数指定要创建的产品。<br />
由于产品种类各不相同，此方法只适用于动态类型语言。<br />
<br />
当所有对象都有相同的基类，且产品对象可以安全的强转成正确的<br />
类型时。才能在 C++这样的静态类型语言中使用。<br />
<br />
此方法有个本质的问题，因为返回的都是 Object 基类，客户无法区分<br />
或对一个产品类别进行安全的假定。需要 dynamic_cast 去转换，这种<br />
自上向下类型的转换并不总是安全的。<br />
<br />
总结：这是一个典型的高度灵活和更高安全性的权衡问题。<br />
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org0f0da10" class="outline-4">
<h4 id="org0f0da10"><span class="section-number-4">8.3.7</span> 相关模式</h4>
<div class="outline-text-4" id="text-8-3-7">
<ul class="org-ul">
<li>Abstract Factory 通常用<a href="#org3494a11">工厂方法</a>实现，也可用 Prototype 实现。</li>
<li>一个具体的工厂通常是一个<a href="#org107c590">单件</a>。</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-orgc99af9a" class="outline-2">
<h2 id="orgc99af9a"><span class="section-number-2">9</span> 命令模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">行为型</span>&#xa0;<span class="__">对象</span></span></h2>
<div class="outline-text-2" id="text-9">
<p>
<a id="org858daf5"></a>
</p>
</div>
<div id="outline-container-orgec43bdc" class="outline-3">
<h3 id="orgec43bdc"><span class="section-number-3">9.1</span> 概述</h3>
<div class="outline-text-3" id="text-9-1">
<p class="verse">
将请求封装成对象，实现统一的 Execute()接口，从而可以使用不同的请求<br />
实例对其他对象进行参数化。<br />
<br />
典型的例子：<br />
Button 控件，对控件设计者来说，只知道 Button 按下应该会发生<br />
些什么，但具体会发生什么一无所知。只能由使用者来决定。<br />
</p>
</div>
</div>

<div id="outline-container-org6f146f8" class="outline-3">
<h3 id="org6f146f8"><span class="section-number-3">9.2</span> 适用性</h3>
<div class="outline-text-3" id="text-9-2">
<ul class="org-ul">
<li><b>回调机制</b> 的一个面向对象的替代品</li>

<li>支持对请求排队</li>

<li><p>
支持撤销操作
</p>
<p class="verse">
Excute()在实施操作前记录状态，Undo()利用该记录状态取消之前执行的操作。<br />
将执行完的命令对象加入一个历史列表，可通过 <b>向前/向后遍历</b> 实现<br />
一系列的 <b>Undo/Redo</b> 。<br />
</p></li>

<li><p>
命令对象支持 <b>持久化</b>
</p>
<p class="verse">
方法：添加 Store()和 Load()接口<br />
在执行一些列命令前，调用 Store()对命令对象进行序列化和持久化操作。<br />
一旦系统崩溃，可以使用 Load()复原命令对象，并重新执行。<br />
</p></li>

<li>支持事务处理</li>
</ul>
</div>
</div>

<div id="outline-container-orge892731" class="outline-3">
<h3 id="orge892731"><span class="section-number-3">9.3</span> 结构</h3>
<div class="outline-text-3" id="text-9-3">

<div class="figure">
<p><img src="../resources/OO/Command.png" alt="Command.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org83b8e79" class="outline-3">
<h3 id="org83b8e79"><span class="section-number-3">9.4</span> 角色</h3>
<div class="outline-text-3" id="text-9-4">
<ul class="org-ul">
<li><p>
Client
</p>
<p class="verse">
负责创建具体命令对象并指定它的接收者。<br />
存储命令对象到某个媒介。<br />
</p></li>

<li>Invoker 从存储媒介中获取命令对象，并执行。</li>
</ul>
</div>
</div>

<div id="outline-container-org2edd0f5" class="outline-3">
<h3 id="org2edd0f5"><span class="section-number-3">9.5</span> 优点</h3>
<div class="outline-text-3" id="text-9-5">
<ol class="org-ol">
<li>增加新的 Command 很容易。</li>
<li>将调用命令的对象与知道如何实现该命令相关操作的对象解耦。</li>
<li>Command 对象和其他对象一样支持扩展。</li>
<li>支持 MacroCommand。复合命令是 Composite 模式的一个实例。</li>
</ol>
</div>
</div>

<div id="outline-container-orge19e682" class="outline-3">
<h3 id="orge19e682"><span class="section-number-3">9.6</span> 实现</h3>
<div class="outline-text-3" id="text-9-6">
<ul class="org-ul">
<li>一个命令对象职责可大可小。
<ul class="org-ul">
<li>最小职责仅确定一个接收者和执行该请求的动作</li>
<li>职责也可以大到负责处理所有的功能，不需要接收者，直接包含具体动作。(当没有合适的接收者时使用)</li>
</ul></li>
<li><p>
实现 undo 和 redo
</p>

<p>
ConcreteCommand 类需要存储额外的状态信息，包括：
</p>

<ul class="org-ul">
<li>接收者对象</li>
<li>接收者接口执行操作的参数</li>
<li>接收者的状态值</li>
</ul></li>

<li><p>
使用 C++模板
</p>
<p class="verse">
好处：避免每一个动作和接收者都创建一个 Command 子类。<br />
问题：1) 不支持撤销操作 2) 无法向接收者的执行接口传入参数<br />
</p></li>
</ul>
</div>
</div>
<div id="outline-container-orgbe3e9b9" class="outline-3">
<h3 id="orgbe3e9b9"><span class="section-number-3">9.7</span> 相关模式</h3>
<div class="outline-text-3" id="text-9-7">
<ul class="org-ul">
<li>Composite 可被用来实现宏命令。</li>
<li>Memento 模式可用来保持一个状态，命令对象用该状态来取消之前执行效果。</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgfb9f23e" class="outline-2">
<h2 id="orgfb9f23e"><span class="section-number-2">10</span> 适配器模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="_">类</span>&#xa0;<span class="__">对象</span>&#xa0;<span class="___">结构型</span></span></h2>
<div class="outline-text-2" id="text-10">
<p>
<a id="orgb7b6e30"></a>
</p>
</div>
<div id="outline-container-org1a4f809" class="outline-3">
<h3 id="org1a4f809"><span class="section-number-3">10.1</span> 概述</h3>
<div class="outline-text-3" id="text-10-1">
<p class="verse">
将一个或多个类的接口转换成用户希望的接口。别名 Wrapper。<br />
现有类的接口与用户希望的接口通常是固定的，无法改变。<br />
</p>
</div>
</div>

<div id="outline-container-orgd307ff3" class="outline-3">
<h3 id="orgd307ff3"><span class="section-number-3">10.2</span> 结构</h3>
<div class="outline-text-3" id="text-10-2">
</div>
<div id="outline-container-orge5496b3" class="outline-4">
<h4 id="orge5496b3"><span class="section-number-4">10.2.1</span> 类适配器</h4>
<div class="outline-text-4" id="text-10-2-1">

<div class="figure">
<p><img src="../resources/OO/ClassAdapter.png" alt="ClassAdapter.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org8ffc854" class="outline-4">
<h4 id="org8ffc854"><span class="section-number-4">10.2.2</span> 对象适配器</h4>
<div class="outline-text-4" id="text-10-2-2">
<p>
将 Adapter 与 Adaptee 之间的继承关系变为了组合。
</p>

<div class="figure">
<p><img src="../resources/OO/InstanceAdapter.png" alt="InstanceAdapter.png" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgfe20aff" class="outline-3">
<h3 id="orgfe20aff"><span class="section-number-3">10.3</span> 角色</h3>
<div class="outline-text-3" id="text-10-3">
<ul class="org-ul">
<li>Target
定义了满足用户需要的接口</li>
</ul>
</div>
</div>

<div id="outline-container-orga2fe9d1" class="outline-3">
<h3 id="orga2fe9d1"><span class="section-number-3">10.4</span> 实现细节</h3>
<div class="outline-text-3" id="text-10-4">
</div>
<div id="outline-container-org9988fa5" class="outline-4">
<h4 id="org9988fa5"><span class="section-number-4">10.4.1</span> 类适配器还是对象适配器？</h4>
<div class="outline-text-4" id="text-10-4-1">
<ul class="org-ul">
<li><p>
重定义 Adaptee 的行为
</p>
<p class="verse">
类适配器可以方便地重定义 Adaptee 的部分行为。<br />
对象适配器可能需要通过<a href="#orgf6c28a6">6</a>模式先拓展 Adaptee。<br />
</p></li>

<li><p>
适配多个 Adaptee？
</p>
<p class="verse">
类适配器只能适配一个 Adaptee。<br />
对象适配器支持多个。<br />
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org3e1f52e" class="outline-4">
<h4 id="org3e1f52e"><span class="section-number-4">10.4.2</span> 双向适配器增加透明性</h4>
<div class="outline-text-4" id="text-10-4-2">
<p class="verse">
适配器因为改变了接口，Adapter 对象与 Adaptee 对象不兼容(提示：<a href="#orgf6c28a6">6</a>兼容)。<br />
原本使用 Adaptee 对象的用户就无法使用 Adapter 对象。<br />
可使用双向适配器，在实现 Target 的同时，保留原本 Adaptee 的接口。<br />
</p>
</div>
</div>
</div>

<div id="outline-container-org8975c20" class="outline-3">
<h3 id="org8975c20"><span class="section-number-3">10.5</span> 相关模式</h3>
<div class="outline-text-3" id="text-10-5">
<ul class="org-ul">
<li><a href="#org08ee5fe">Bridge</a>模式的结构与其有些相似，但意图不同。Bridge 的目的是将接口部分与实现部分分离。</li>
<li><a href="#orgf6c28a6">Decorator</a>模式为类增加职责，不改变 <b>原先</b> 的接口。</li>
<li>透明性比<a href="#orgb7b6e30">Adapter</a>好，并支持递归组合。</li>
<li><a href="#orgf26c067">Proxy</a>模式在不改变其接口的条件下，为另一个对象定义了一个代理。</li>
<li><a href="#org7d3d8af">Facade</a>模式将一个或多个不同对象的复杂接口进行简化。</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org9770a56" class="outline-2">
<h2 id="org9770a56"><span class="section-number-2">11</span> 代理模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="__">对象</span>&#xa0;<span class="___">结构型</span></span></h2>
<div class="outline-text-2" id="text-11">
<p>
<a id="orgf26c067"></a>
</p>
</div>
<div id="outline-container-orgf5a5cfb" class="outline-3">
<h3 id="orgf5a5cfb"><span class="section-number-3">11.1</span> 概述</h3>
<div class="outline-text-3" id="text-11-1">
<p>
控制和管理访问
</p>
</div>
</div>
<div id="outline-container-org0202e72" class="outline-3">
<h3 id="org0202e72"><span class="section-number-3">11.2</span> 适用性</h3>
<div class="outline-text-3" id="text-11-2">
<ol class="org-ol">
<li><b>远程代理</b> 代理类隐藏网络层的实现，本地调用代理类就如同调用本地对象一样。</li>
<li><b>虚代理</b> 创建开销很大的对象时使用。代理类隐藏创建的细节。</li>
<li><b>保护代理</b> 用于权限控制。</li>
<li><b>智能指针</b></li>
</ol>
</div>
</div>
<div id="outline-container-org1fab89b" class="outline-3">
<h3 id="org1fab89b"><span class="section-number-3">11.3</span> 结构</h3>
<div class="outline-text-3" id="text-11-3">

<div class="figure">
<p><img src="../resources/OO/Proxy.png" alt="Proxy.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org7ab22d1" class="outline-3">
<h3 id="org7ab22d1"><span class="section-number-3">11.4</span> 角色</h3>
<div class="outline-text-3" id="text-11-4">
<ul class="org-ul">
<li><p>
Proxy
</p>

<p>
控制对实体的存取，并可能负责创建和删除实体。
</p></li>

<li><p>
Subject
</p>

<p>
定义 RealSubject 与 Proxy 的共用接口。
</p></li>
</ul>
</div>
</div>
<div id="outline-container-org79a04ec" class="outline-3">
<h3 id="org79a04ec"><span class="section-number-3">11.5</span> 实现细节</h3>
<div class="outline-text-3" id="text-11-5">
</div>
<div id="outline-container-orgfddc923" class="outline-4">
<h4 id="orgfddc923"><span class="section-number-4">11.5.1</span> C++通过重载-&gt;,*运算符实现</h4>
<div class="outline-text-4" id="text-11-5-1">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #ba2f59; font-weight: bold;">Image</span>* <span style="color: #4e3163;">ImageProxy</span>::<span style="color: #3a81c3; font-weight: bold;">operator</span><span style="color: #6c3163; font-weight: bold;">-&gt;</span> ()
{
    <span style="color: #3a81c3; font-weight: bold;">return</span> LoadImage();
}
<span style="color: #ba2f59; font-weight: bold;">Image</span>&amp; <span style="color: #4e3163;">ImageProxy</span>::<span style="color: #3a81c3; font-weight: bold;">operator</span><span style="color: #6c3163; font-weight: bold;">*</span> ()
{
    <span style="color: #3a81c3; font-weight: bold;">return</span> *LoadImage();
}

<span style="color: #ba2f59; font-weight: bold;">int</span> <span style="color: #6c3163; font-weight: bold;">main</span>()
{
    <span style="color: #ba2f59; font-weight: bold;">ImageProxy</span> <span style="color: #715ab1;">imageptr</span>;
    imageptr-&gt;Draw();<span style="color: #2aa1ae; background-color: #ecf3ec;">//</span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#27492;&#22788;&#23454;&#38469;&#35843;&#29992;&#30340;&#26159; Image &#30340;&#26041;&#27861;</span>
    (*image).Draw();
    <span style="color: #3a81c3; font-weight: bold;">return</span> 0;
}

</pre>
</div>
</div>
</div>
<div id="outline-container-org5b77e15" class="outline-4">
<h4 id="org5b77e15"><span class="section-number-4">11.5.2</span> 远程代理</h4>
<div class="outline-text-4" id="text-11-5-2">
<p class="verse">
远程代理不一定都是通过网络调用的，不同地址空间的对象访问也是远程代理。<br />
远程代理一般需要将对象、调用信息序列化，通过 Socket 等协议，通知远程的<br />
服务，然后有远程提供服务的程序，调用实体对象。<br />
<br />
Java 中有成套的解决方案，叫做 RMI。<br />
</p>
</div>
</div>
<div id="outline-container-orgaa7bbc4" class="outline-4">
<h4 id="orgaa7bbc4"><span class="section-number-4">11.5.3</span> 智能指针</h4>
<div class="outline-text-4" id="text-11-5-3">
<ul class="org-ul">
<li>对指向实际对象的引用计数，引用计数为 0 时，自动释放。</li>
<li>第一次引用时，装入内存。</li>
<li>访问实际对象前，检查被锁定。</li>
</ul>

<p>
标准库的例子：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #6c3163;">#include</span> <span style="color: #2d9574;">&lt;memory&gt;</span>
<span style="color: #3a81c3; font-weight: bold;">using</span> <span style="color: #3a81c3; font-weight: bold;">namespace</span> <span style="color: #4e3163;">std</span>;
<span style="color: #3a81c3; font-weight: bold;">class</span> <span style="color: #ba2f59; font-weight: bold;">A</span> {};
<span style="color: #ba2f59; font-weight: bold;">void</span> <span style="color: #6c3163; font-weight: bold;">f</span>()
{
    <span style="color: #ba2f59; font-weight: bold;">auto_ptr</span>&lt;<span style="color: #ba2f59; font-weight: bold;">A</span>&gt; <span style="color: #715ab1;">ptr</span>(<span style="color: #3a81c3; font-weight: bold;">new</span> <span style="color: #ba2f59; font-weight: bold;">A</span>);<span style="color: #2aa1ae; background-color: #ecf3ec;">//</span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#26632;&#21306;&#23545;&#35937;&#65292;&#20986;&#26632;&#26102;&#37322;&#25918;&#25351;&#38024;&#65292;&#36991;&#20813;&#22810;&#20010;&#20989;&#25968;&#20986;&#21475;&#37117;&#20889;&#37322;&#25918;&#35821;&#21477;</span>
    <span style="color: #3a81c3; font-weight: bold;">try</span>
    {
        <span style="color: #2aa1ae; background-color: #ecf3ec;">//</span><span style="color: #2aa1ae; background-color: #ecf3ec;">delete a;</span>
        <span style="color: #3a81c3; font-weight: bold;">return</span>;
    }
    <span style="color: #3a81c3; font-weight: bold;">catch</span> (...)
    {
        <span style="color: #2aa1ae; background-color: #ecf3ec;">//</span><span style="color: #2aa1ae; background-color: #ecf3ec;">delete a;</span>
    }
    <span style="color: #2aa1ae; background-color: #ecf3ec;">//</span><span style="color: #2aa1ae; background-color: #ecf3ec;">delete a;</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd427a35" class="outline-4">
<h4 id="orgd427a35"><span class="section-number-4">11.5.4</span> 虚代理</h4>
<div class="outline-text-4" id="text-11-5-4">
<p class="verse">
对于一些开销很大的对象，可能在实际真正用到的时候，才创建对象。<br />
例如：ImageProxy 构造中什么都不做，而在 Draw 的接口中，才真正创建 Image 对象。<br />
</p>
</div>
</div>
</div>

<div id="outline-container-org13256c2" class="outline-3">
<h3 id="org13256c2"><span class="section-number-3">11.6</span> 相关模式</h3>
<div class="outline-text-3" id="text-11-6">
<ul class="org-ul">
<li><p>
<a href="#orgb7b6e30">Adapter</a>模式：
</p>

<p>
主要用于转换接口；而代理模式一般情况下不改变接口，意图不一样。
</p></li>

<li><p>
<a href="#orgf6c28a6">Decorator</a>模式：两者结构类似，但意图不同。
</p>
<p class="verse">
装饰者模式支持多层装饰；而代理通常只会添加一层访问控制。<br />
代理模式通常与实际对象接口保持一致。装饰者通常需要增加接口以达到扩展功能的目的。<br />
</p></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgdefe5f1" class="outline-2">
<h2 id="orgdefe5f1"><span class="section-number-2">12</span> 外观模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="__">对象</span>&#xa0;<span class="___">结构型</span></span></h2>
<div class="outline-text-2" id="text-12">
<p>
<a id="org7d3d8af"></a>
</p>
</div>
<div id="outline-container-orgfc095c4" class="outline-3">
<h3 id="orgfc095c4"><span class="section-number-3">12.1</span> 概述</h3>
<div class="outline-text-3" id="text-12-1">
<p>
为子系统中的一组接口进行简化，提供一组高级接口，使得子系统更加容易使用。
</p>
</div>
</div>
<div id="outline-container-org85c0abe" class="outline-3">
<h3 id="org85c0abe"><span class="section-number-3">12.2</span> 适用性</h3>
<div class="outline-text-3" id="text-12-2">
<ul class="org-ul">
<li>为复杂子系统提供一个简单接口，对大部分用户来说足够用，必要时用户一样可以绕过该接口。</li>
<li>使客户程序从子系统的各层次实现的细节中解脱出来。</li>
<li>多层次结构，可以使用 Facade 模式定义每一层的抽象操作。可以让各层次之间通过 facade 进行通信，简化了各层次之间的依赖关系。</li>
</ul>
</div>
</div>
<div id="outline-container-org8caefa1" class="outline-3">
<h3 id="org8caefa1"><span class="section-number-3">12.3</span> 结构</h3>
<div class="outline-text-3" id="text-12-3">

<div class="figure">
<p><img src="../resources/OO/Facade.png" alt="Facade.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-orgfbedcbc" class="outline-3">
<h3 id="orgfbedcbc"><span class="section-number-3">12.4</span> 优点</h3>
<div class="outline-text-3" id="text-12-4">
<ul class="org-ul">
<li>实现了用户与子系统之间的 <b>松耦合</b> 关系</li>
<li>对用户屏蔽子系统结构，更易用</li>
</ul>
</div>
</div>
<div id="outline-container-org248dbdb" class="outline-3">
<h3 id="org248dbdb"><span class="section-number-3">12.5</span> 实现细节</h3>
<div class="outline-text-3" id="text-12-5">
<ul class="org-ul">
<li>使用抽象类实现 Facade 可以进一步降低客户与子系统的耦合度。</li>
<li>C++使用 Namespace 可以私有化子系统中的类。</li>
</ul>
</div>
</div>
<div id="outline-container-orgf9625c4" class="outline-3">
<h3 id="orgf9625c4"><span class="section-number-3">12.6</span> 相关模式</h3>
<div class="outline-text-3" id="text-12-6">
<ul class="org-ul">
<li><a href="#org5c088ad">Abstract Factory</a>模式可与 Facade 模式一起使用以提供一个单独的创建产品簇的接口。</li>
<li>Mediator 模式与 Facade 模式的相似之处：都抽象了一些已有的类的功能。但 Mediator 的目的是对同级之间的任意通讯进行抽象。</li>
<li>通常来说仅需要一个 Facade 对象，所以 Facade 类定义成 Singleton 类。</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgd412874" class="outline-2">
<h2 id="orgd412874"><span class="section-number-2">13</span> 迭代器模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="__">对象</span>&#xa0;<span class="___">结构型</span></span></h2>
<div class="outline-text-2" id="text-13">
<p>
<a id="org277a287"></a>
</p>
</div>
<div id="outline-container-orge13dd05" class="outline-3">
<h3 id="orge13dd05"><span class="section-number-3">13.1</span> 概述</h3>
<div class="outline-text-3" id="text-13-1">
<p>
提供遍历集合对象中各元素的方法，并且不将集合具体的数据结构暴露给用户。
</p>
</div>
</div>
<div id="outline-container-orgf67a8a3" class="outline-3">
<h3 id="orgf67a8a3"><span class="section-number-3">13.2</span> 适用性</h3>
<div class="outline-text-3" id="text-13-2">
<ul class="org-ul">
<li>遍历访问集合对象的内容，无需暴露它的内部结构。</li>
<li>支持对同一集合对象的多种遍历方式。</li>
<li>为遍历不同数据结构的集合对象提供统一的接口(即支持多态迭代）。</li>
</ul>
</div>
</div>
<div id="outline-container-org6446ab2" class="outline-3">
<h3 id="org6446ab2"><span class="section-number-3">13.3</span> 结构</h3>
<div class="outline-text-3" id="text-13-3">

<div class="figure">
<p><img src="../resources/OO/Iterator.png" alt="Iterator.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org837632b" class="outline-3">
<h3 id="org837632b"><span class="section-number-3">13.4</span> 角色</h3>
<div class="outline-text-3" id="text-13-4">
<ul class="org-ul">
<li><p>
Iterator
</p>

<p>
定义访问和遍历元素的接口
</p></li>

<li>ConcreteIterator

<ul class="org-ul">
<li>实现 Iterator 定义的接口</li>
<li>在遍历集合时，跟踪当前位置</li>
</ul></li>

<li><p>
Aggregate
</p>

<p>
定义创建迭代器对象的接口
</p></li>

<li><p>
ConcreteAggregate
</p>

<p>
实现 Aggregate 定义的接口
</p></li>
</ul>
</div>
</div>
<div id="outline-container-org0bf4ed9" class="outline-3">
<h3 id="org0bf4ed9"><span class="section-number-3">13.5</span> 优点</h3>
<div class="outline-text-3" id="text-13-5">
<ul class="org-ul">
<li>支持以不同的方式遍历一个集合，使改变遍历算法变的容易。</li>
<li>迭代器将遍历的职责从集合类中剥离出来。维护起来更容易。</li>
<li>可以同时对一个集合进行多个遍历，只需多个迭代器实例对象。</li>
</ul>
</div>
</div>
<div id="outline-container-orgec98553" class="outline-3">
<h3 id="orgec98553"><span class="section-number-3">13.6</span> 实现细节</h3>
<div class="outline-text-3" id="text-13-6">
</div>
<div id="outline-container-org03f667a" class="outline-4">
<h4 id="org03f667a"><span class="section-number-4">13.6.1</span> 由谁来控制迭代过程？</h4>
<div class="outline-text-4" id="text-13-6-1">
<p class="verse">
由客户来控制的称为外部迭代器(或称为主动迭代器)。<br />
由迭代器自身来控制的，称为内部迭代器(或称为被动迭代器)。<br />
</p>

<ul class="org-ul">
<li><p>
外部迭代器
</p>

<p>
使用外部迭代器时，客户必须主动推进迭代的步伐。
</p></li>

<li><p>
内部迭代器
</p>
<p class="verse">
使用内部迭代器时，客户只需指定一个操作，迭代器保证对集合<br />
中的每一个元素执行该操作。<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup><br />
如何指定操作？支持匿名函数和闭包的语言很容易实现。<br />
C++中通常有两种方法可以选择<br />
</p>
<ul class="org-ul">
<li>函数指针
劣势在于如果需要更新某种状态，则需要使用全局变量。</li>
<li>子类生成
需要定义额外的类来达到目的。<sup><a id="fnr.4" class="footref" href="#fn.4">4</a></sup></li>
</ul></li>

<li><p>
权衡
</p>
<p class="verse">
内部迭代器定义好了迭代逻辑，使用起来更方便；<br />
外部迭代器由于将迭代逻辑交由用户来控制，使用起来更灵活。<br />
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org12b3ce3" class="outline-4">
<h4 id="org12b3ce3"><span class="section-number-4">13.6.2</span> 谁定义遍历算法？</h4>
<div class="outline-text-4" id="text-13-6-2">
<ul class="org-ul">
<li><p>
由集合自身定义
</p>
<p class="verse">
由集合自身定义遍历算法。迭代器仅用来指示当前的位置。这种迭代器称为 <b>游标</b> 。<br />
<br />
客户调用 Next()时，需要将游标作为参数传入，Next 操作内部仅改变游标的位置状态。<br />
可改接口为 SetCursor(index)和 int GetCursor()更容易理解。<br />
</p></li>
<li><p>
由迭代器定义
</p>
<p class="verse">
遍历算法还可以由迭代器定义，优势在于，使得在相同的集合上使用不同的迭代算法、<br />
或是在不同的集合上使用相同的迭代算法更简单。<br />
<br />
注意：如果遍历算法会用到集合的私有变量，放在迭代器中，则破坏了集合对象的封装性。<br />
</p></li>
</ul>
</div>
</div>
<div id="outline-container-org272f605" class="outline-4">
<h4 id="org272f605"><span class="section-number-4">13.6.3</span> 线程安全的迭代器</h4>
<div class="outline-text-4" id="text-13-6-3">
<p class="verse">
现实情况下，可能有多个不同线程创建的迭代器引用同一个集合对象。<br />
<br />
解决同步问题的一般做法是：<br />
各迭代器对象需要向集合对象进行注册(可用<a href="#org42e2307">4</a>模式)，<br />
当改变发生时，集合对象更新每一个迭代器的状态。<br />
</p>
</div>
</div>
<div id="outline-container-org9e6bf35" class="outline-4">
<h4 id="org9e6bf35"><span class="section-number-4">13.6.4</span> 关于多态迭代器</h4>
<div class="outline-text-4" id="text-13-6-4">
<ul class="org-ul">
<li><p>
结构图中所展示的是多态迭代器的实现
</p>
<p class="verse">
也可以不需要迭代器抽象基类，这样在 <b>工厂方法 CreateIterator</b> 中<br />
也就不需要动态 new 出迭代器具体类对象。<br />
</p></li>

<li><p>
多态迭代器是有代价的
</p>
<p class="verse">
因为 <b>动态</b> 的分配迭代器对象的本身是有代价的。<br />
一般情况使用分配在栈区上的具体迭代器即可。<br />
</p></li>
<li><p>
多态意味着需要用 new，也就需要用户负责删除它们，这样容易引发错误。
</p>
<p class="verse">
可以使用<a href="#orgf26c067">11</a>模式，在栈区创建一个代理迭代器对象，在代理迭代器析构中<br />
释放具体迭代器对象。不能用工厂是因为工厂只负责对象的创建。<br />
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #4e3163;">IteratorProxy</span>::<span style="color: #6c3163; font-weight: bold;">IteratorProxy</span>(<span style="color: #ba2f59; font-weight: bold;">Type</span> <span style="color: #715ab1;">type</span>)
{
  <span style="color: #3a81c3; font-weight: bold;">if</span> (type == Type.Reverse) <span style="color: #ba2f59; font-weight: bold;">Iterator</span>* <span style="color: #715ab1;">m_iter</span> = <span style="color: #3a81c3; font-weight: bold;">new</span> <span style="color: #ba2f59; font-weight: bold;">ReverseIterator</span>();
  ...;
}

<span style="color: #4e3163;">IteratorProxy</span>::~<span style="color: #6c3163; font-weight: bold;">IteratorProxy</span>()
{
  <span style="color: #3a81c3; font-weight: bold;">delete</span> m_iter;
}

<span style="color: #ba2f59; font-weight: bold;">int</span> <span style="color: #6c3163; font-weight: bold;">main</span>()
{
  <span style="color: #ba2f59; font-weight: bold;">IteratorProxy</span> <span style="color: #715ab1;">iter</span>(Type.Reverse);
  iter.next();
  ...;
  <span style="color: #3a81c3; font-weight: bold;">return</span> 0;
}

</pre>
</div></li>
</ul>


<ul class="org-ul">
<li>仅在必须要使用多态时才使用。</li>
</ul>
</div>
</div>

<div id="outline-container-orge2b8f5b" class="outline-4">
<h4 id="orge2b8f5b"><span class="section-number-4">13.6.5</span> 迭代器与集合的紧密耦合</h4>
<div class="outline-text-4" id="text-13-6-5">
<p>
迭代器一般作为集合的一个扩展，两者之间是紧密耦合的。
</p>
</div>

<ul class="org-ul">
<li><a id="org9d96f58"></a>利用 C++友元实现<br />
<div class="outline-text-5" id="text-org9d96f58">
<p class="verse">
C++中迭代器可作为它的集合类的一个友元，<br />
这样集合类中就不必定义一些只有迭代器才用的到的方法。<br />
当然这破坏了集合类的封装性，但这点仅仅是针对迭代器而言的。<br />
<br />
问题：<br />
当定义新的 ConcreteIterator(为了增加新的遍历方式)时，需要为集合类加上另一个友元。<br />
<br />
解决办法：<br />
为避免该问题，集合类可定义迭代器父类为友元，<br />
迭代器子类通过包含一些 protected 操作，来访问集合类非公共可见成员。<br />
</p>
</div>
</li>
</ul>
</div>
<div id="outline-container-org4f939da" class="outline-4">
<h4 id="org4f939da"><span class="section-number-4">13.6.6</span> 与<a href="#org79ace22">16</a>模式的协作</h4>
</div>
<div id="outline-container-org3ae1415" class="outline-4">
<h4 id="org3ae1415"><span class="section-number-4">13.6.7</span> 空迭代器</h4>
<div class="outline-text-4" id="text-13-6-7">
<p class="verse">
用于处理边界条件。<br />
一个 NullIterator 的 IsDone()总是返回 true，或者 HasNext()总是返回 false。<br />
<br />
提示：<br />
空迭代器更多的用于处理树形结构的集合。<br />
叶结点通常需要一个 NullIterator。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org52deceb" class="outline-3">
<h3 id="org52deceb"><span class="section-number-3">13.7</span> 相关模式</h3>
<div class="outline-text-3" id="text-13-7">
<ul class="org-ul">
<li>迭代器可在<a href="#org79ace22">Composite</a>模式这样的递归结构上使用。</li>
<li>多态迭代器可以通过<a href="#org3494a11">Factory Method</a>模式来实例化迭代器子类。</li>
<li>迭代器可使用一个 memento 来捕获一个迭代状态，即迭代器内部存储 memento。</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org36339ac" class="outline-2">
<h2 id="org36339ac"><span class="section-number-2">14</span> 桥接模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="__">对象</span>&#xa0;<span class="___">结构型</span></span></h2>
<div class="outline-text-2" id="text-14">
<p>
<a id="org08ee5fe"></a>
</p>
</div>
<div id="outline-container-org5aed93f" class="outline-3">
<h3 id="org5aed93f"><span class="section-number-3">14.1</span> 概述</h3>
<div class="outline-text-3" id="text-14-1">
<p>
分离抽象部分与实现部分，使得抽象部分也能被改变。
</p>
</div>
</div>
<div id="outline-container-orgcf97c50" class="outline-3">
<h3 id="orgcf97c50"><span class="section-number-3">14.2</span> 适用性</h3>
<div class="outline-text-3" id="text-14-2">
<ul class="org-ul">
<li>多用于需要跨多个平台的 GUI 部分。</li>
</ul>
</div>
</div>
<div id="outline-container-orgd3b9d0f" class="outline-3">
<h3 id="orgd3b9d0f"><span class="section-number-3">14.3</span> 结构</h3>
<div class="outline-text-3" id="text-14-3">

<div class="figure">
<p><img src="../resources/OO/Bridge.png" alt="Bridge.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org209c0fc" class="outline-3">
<h3 id="org209c0fc"><span class="section-number-3">14.4</span> 优缺点</h3>
<div class="outline-text-3" id="text-14-4">
</div>
<div id="outline-container-org2051e8b" class="outline-4">
<h4 id="org2051e8b"><span class="section-number-4">14.4.1</span> 优点</h4>
<div class="outline-text-4" id="text-14-4-1">
<ul class="org-ul">
<li>将实现解耦，不再与界面(接口)绑定死。</li>
<li>接口也可独立扩展。</li>
<li>对接口扩展也不会影响到现有客户。</li>
</ul>
</div>
</div>
<div id="outline-container-orgbc57600" class="outline-4">
<h4 id="orgbc57600"><span class="section-number-4">14.4.2</span> 缺点</h4>
<div class="outline-text-4" id="text-14-4-2">
<ul class="org-ul">
<li>增加架构复杂度</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org2647d9f" class="outline-3">
<h3 id="org2647d9f"><span class="section-number-3">14.5</span> 实现细节</h3>
<div class="outline-text-3" id="text-14-5">
</div>
<div id="outline-container-orgf92b1b8" class="outline-4">
<h4 id="orgf92b1b8"><span class="section-number-4">14.5.1</span> Implementor 具体对象的创建</h4>
<div class="outline-text-4" id="text-14-5-1">
<ul class="org-ul">
<li>可由 Abstraction 的构造方法的参数，在构造中确定创建哪个对象。</li>
<li>可提供缺省的创建，根据需要改变具体对象。</li>
<li><p>
代理给其他对象，由其他对象来决定。
</p>
<p class="verse">
比如，由一些 factory 对象来决定，可以使 Abstraction<br />
和 Implementor 对象彻底解耦。<br />
</p></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org992a431" class="outline-3">
<h3 id="org992a431"><span class="section-number-3">14.6</span> 相关模式</h3>
<div class="outline-text-3" id="text-14-6">
<p class="verse">
<a href="#orgb7b6e30">Adapter</a> 通常在系统设计完成后才会被使用，Bridge 则在系统设计开始<br />
时就被使用，它使得抽象与实现可以独立的进行改变。<br />
</p>
</div>
</div>
</div>

<div id="outline-container-org62ad1b9" class="outline-2">
<h2 id="org62ad1b9"><span class="section-number-2">15</span> 生成器模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">创建型</span>&#xa0;<span class="__">对象</span></span></h2>
<div class="outline-text-2" id="text-15">
<p>
<a id="org4080251"></a>
</p>
</div>
<div id="outline-container-org80a387a" class="outline-3">
<h3 id="org80a387a"><span class="section-number-3">15.1</span> 概述</h3>
<div class="outline-text-3" id="text-15-1">
<p>
将一个复杂对象的创建过程封装起来，提供接口创建复杂对象的各部件。
</p>
</div>
</div>
<div id="outline-container-org47c1cf1" class="outline-3">
<h3 id="org47c1cf1"><span class="section-number-3">15.2</span> 结构</h3>
<div class="outline-text-3" id="text-15-2">

<div class="figure">
<p><img src="../resources/OO/Builder.png" alt="Builder.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org7b64898" class="outline-3">
<h3 id="org7b64898"><span class="section-number-3">15.3</span> 角色</h3>
<div class="outline-text-3" id="text-15-3">
<ul class="org-ul">
<li><p>
Builder
</p>

<p>
为创建一个 Product 对象的各个部件指定抽象接口。
</p></li>

<li>ConcreteBuilder
<ul class="org-ul">
<li>实现 Builder 的接口以构造和装配该产品的各个部件</li>
<li>定义产品的内部表示，及其各部件的装配过程</li>
<li>提供一个检索产品的接口 GetResult</li>
</ul></li>

<li><p>
Director
</p>

<p>
构造一个使用 Builder 接口的对象
</p></li>
</ul>
</div>
</div>

<div id="outline-container-orgd719773" class="outline-3">
<h3 id="orgd719773"><span class="section-number-3">15.4</span> 流程图</h3>
<div class="outline-text-3" id="text-15-4">

<div class="figure">
<p><img src="../resources/OO/BuilderSeq.png" alt="BuilderSeq.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org7fcca11" class="outline-3">
<h3 id="org7fcca11"><span class="section-number-3">15.5</span> 效果</h3>
<div class="outline-text-3" id="text-15-5">
<ul class="org-ul">
<li>只需定义一个新的生成器就可以改变产品内部表示</li>
<li>创建与表示分开，客户无需知道产品内部的部件类</li>
</ul>
</div>
</div>
<div id="outline-container-org23cb92a" class="outline-3">
<h3 id="org23cb92a"><span class="section-number-3">15.6</span> 实现</h3>
<div class="outline-text-3" id="text-15-6">
<ul class="org-ul">
<li><p>
产品不是抽象类？
</p>

<p>
通常具体生成器生成的产品之间相差很大，不太可能有公有接口。
</p></li>

<li>通常缺省 BuildPart 方法什么也不做，但非纯虚方法</li>
</ul>
</div>
</div>

<div id="outline-container-org66948ab" class="outline-3">
<h3 id="org66948ab"><span class="section-number-3">15.7</span> 相关模式</h3>
<div class="outline-text-3" id="text-15-7">
<ul class="org-ul">
<li><a href="#org5c088ad">Abstract Factory</a>着重于多个系列产品对象，生成器专注于创建复杂对象，最后一步才返回产品。</li>
<li><a href="#org79ace22">Composite</a>通常是用 Builder 生成的。</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgb4cfee1" class="outline-2">
<h2 id="orgb4cfee1"><span class="section-number-2">16</span> 组合模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">结构型</span>&#xa0;<span class="__">对象</span></span></h2>
<div class="outline-text-2" id="text-16">
<p>
<a id="org79ace22"></a>
</p>
</div>
<div id="outline-container-orge607c41" class="outline-3">
<h3 id="orge607c41"><span class="section-number-3">16.1</span> 概述</h3>
<div class="outline-text-3" id="text-16-1">
<p class="verse">
将对象组合成树形结构，表现出“整体/部分”的层次。<br />
用户对于单个对象的使用和组合对象的使用具有一致性。<br />
</p>
</div>
</div>

<div id="outline-container-orgdb52579" class="outline-3">
<h3 id="orgdb52579"><span class="section-number-3">16.2</span> 结构</h3>
<div class="outline-text-3" id="text-16-2">

<div class="figure">
<p><img src="../resources/OO/Composite.png" alt="Composite.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org30b49b9" class="outline-3">
<h3 id="org30b49b9"><span class="section-number-3">16.3</span> 角色</h3>
<div class="outline-text-3" id="text-16-3">
<ul class="org-ul">
<li>Component
<ul class="org-ul">
<li>声明组合和叶对象的一致操作 Operation。</li>
<li>在适当情况下，实现所有类的默认行为。</li>
<li>声明用于访问和管理 Component 子部件的接口。</li>
</ul></li>
<li>Composite
<ul class="org-ul">
<li>实现有子部件的 Operation 行为。</li>
<li>存储子部件。</li>
<li>实现访问和管理子部件的接口。</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgb9d7ac5" class="outline-3">
<h3 id="orgb9d7ac5"><span class="section-number-3">16.4</span> 优点</h3>
<div class="outline-text-3" id="text-16-4">
<ul class="org-ul">
<li><p>
简化客户代码，客户可以一致的使用组合对象和叶对象。
</p>
<p class="verse">
用户不关心是何种对象，也就不需要写一些选择语句。<br />
</p></li>
<li>容易增加新类型的组件。</li>
</ul>
</div>
</div>

<div id="outline-container-orgf23b5f7" class="outline-3">
<h3 id="orgf23b5f7"><span class="section-number-3">16.5</span> 实现</h3>
<div class="outline-text-3" id="text-16-5">
<ul class="org-ul">
<li><p>
子部件可保存父部件的引用。
</p>
<p class="verse">
父部件引用也支持<a href="#org90ec527">17</a>。<br />
父部件引用一般定义在 Component 类中。<br />
</p></li>

<li>共享组件，可减少对存储的需求。</li>

<li><p>
透明性与安全性的权衡
</p>
<p class="verse">
如需更多的透明性，将操作子部件的 Add 操作和 Remove 操作在 Component 类中定义。<br />
如需更高的安全性，将这些操作在 Composite 类中定义。安全性会需要用到类型转换。<br />
</p></li>
<li><p>
存储子结点的引用集合
</p>
<p class="verse">
对于叶结点而言，会有一定的空间浪费，需考虑。<br />
</p></li>
<li><p>
子部件顺序问题
</p>
<p class="verse">
有时候子结点的顺序可能是有意义的。比如语法分析树。<br />
这时候需要仔细设计对子结点的访问和管理接口，可使用 Iterator 模式。<br />
</p></li>
<li>Composite 存储子结点的数据结构是可选的</li>
</ul>
</div>
</div>

<div id="outline-container-orgbc5f601" class="outline-3">
<h3 id="orgbc5f601"><span class="section-number-3">16.6</span> 相关模式</h3>
<div class="outline-text-3" id="text-16-6">
<ul class="org-ul">
<li>部件到父部件的连接使用<a href="#org90ec527">Chain of Responsibility</a></li>
<li><a href="#orgf6c28a6">Decorator</a>与 Composite 模式很像，事实上他们经常可以一起使用。</li>
<li>Flyweight 可以帮助实现共享组件。</li>
<li><a href="#org277a287">Iterator</a>可用来遍历 Composite 子部件。</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org8fb2506" class="outline-2">
<h2 id="org8fb2506"><span class="section-number-2">17</span> 责任链模式</h2>
<div class="outline-text-2" id="text-17">
<p>
<a id="org90ec527"></a>
</p>
</div>
<div id="outline-container-orgc5ce8a6" class="outline-3">
<h3 id="orgc5ce8a6"><span class="section-number-3">17.1</span> 概述</h3>
<div class="outline-text-3" id="text-17-1">
<p class="verse">
使多个对象都有机会处理请求，将这些对象连成一条链，沿着该链传递该请求，<br />
直到有对象处理该请求为止。<br />
通俗点讲，每个处理对象能处理请求就处理掉，否则就扔给下一个处理对象。<br />
</p>
</div>
</div>

<div id="outline-container-org553f18b" class="outline-3">
<h3 id="org553f18b"><span class="section-number-3">17.2</span> 结构</h3>
<div class="outline-text-3" id="text-17-2">

<div class="figure">
<p><img src="../resources/OO/ChainOfResponsibility.png" alt="ChainOfResponsibility.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org1a56a72" class="outline-3">
<h3 id="org1a56a72"><span class="section-number-3">17.3</span> 适用性</h3>
<div class="outline-text-3" id="text-17-3">
<ul class="org-ul">
<li>经常被用来处理鼠标键盘事件。</li>
<li>过滤器的实现可参考责任链模式。</li>
</ul>
</div>
</div>

<div id="outline-container-org49d66da" class="outline-3">
<h3 id="org49d66da"><span class="section-number-3">17.4</span> 优点</h3>
<div class="outline-text-3" id="text-17-4">
<ul class="org-ul">
<li><p>
降低耦合度
</p>

<p>
请求者不关心谁处理了请求。责任链中对象也无需知道链结构。
</p></li>

<li>可以动态地增加修改 Handler 对象</li>
</ul>
</div>
</div>

<div id="outline-container-org8d29404" class="outline-3">
<h3 id="org8d29404"><span class="section-number-3">17.5</span> 缺点</h3>
<div class="outline-text-3" id="text-17-5">
<ul class="org-ul">
<li>不保证请求一定会被处理。</li>
<li>不容易观察运行时特征，不利于除错。</li>
</ul>
</div>
</div>

<div id="outline-container-org0f49d16" class="outline-3">
<h3 id="org0f49d16"><span class="section-number-3">17.6</span> 实现</h3>
<div class="outline-text-3" id="text-17-6">
</div>
<div id="outline-container-orgf575fde" class="outline-4">
<h4 id="orgf575fde"><span class="section-number-4">17.6.1</span> 后继者实现</h4>
<div class="outline-text-4" id="text-17-6-1">
<p class="verse">
通常 Handler 类维护后继者链接，并提供默认实现向后继者转发请求。<br />
如果 ConcreteHandler 类对该请求不感兴趣，它只需要用到默认实现转发请求即可。<br />
</p>
</div>
</div>

<div id="outline-container-org51da4d9" class="outline-4">
<h4 id="org51da4d9"><span class="section-number-4">17.6.2</span> 请求的表示</h4>
<div class="outline-text-4" id="text-17-6-2">
<ul class="org-ul">
<li><p>
单一类型请求
</p>

<p>
通过一个 hard-coded 操作调用，这种方式方便安全。
</p></li>

<li><p>
多个类型的一组请求
</p>

<p>
处理函数参数需要一个请求码，用条件语句区分请求码以分派请求。
</p></li>

<li>使用独立的请求对象</li>
</ul>
</div>
</div>

<div id="outline-container-org7ad9aff" class="outline-4">
<h4 id="org7ad9aff"><span class="section-number-4">17.6.3</span> 终极 Handler</h4>
<div class="outline-text-4" id="text-17-6-3">
<p>
责任链不保证请求一定会被处理，可以在最后加个终极处理器处理这种情况。
</p>
</div>
</div>
</div>


<div id="outline-container-org5b78759" class="outline-3">
<h3 id="org5b78759"><span class="section-number-3">17.7</span> 相关模式</h3>
<div class="outline-text-3" id="text-17-7">
<p class="verse">
责任链通常与<a href="#org79ace22">Composite</a>一起使用。一个部件的后继者可以是它的父部件。<br />
子部件能处理则处理，不能处理则一层层交由父部件处理。<br />
</p>
</div>
</div>
</div>

<div id="outline-container-org684a0c9" class="outline-2">
<h2 id="org684a0c9"><span class="section-number-2">18</span> 一些 OO 提示</h2>
<div class="outline-text-2" id="text-18">
</div>
<div id="outline-container-orga3b7994" class="outline-3">
<h3 id="orga3b7994"><span class="section-number-3">18.1</span> 活用空对象来避免 null 值检查</h3>
<div class="outline-text-3" id="text-18-1">
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #3a81c3; font-weight: bold;">class</span> <span style="color: #ba2f59; font-weight: bold;">Object</span>
{
<span style="color: #3a81c3; font-weight: bold;">public</span>:
    vitual <span style="color: #ba2f59; font-weight: bold;">void</span> <span style="color: #6c3163; font-weight: bold;">DoSomething</span>() = 0;
};

<span style="color: #3a81c3; font-weight: bold;">class</span> <span style="color: #ba2f59; font-weight: bold;">NullObject</span> : <span style="color: #3a81c3; font-weight: bold;">public</span> <span style="color: #ba2f59; font-weight: bold;">Object</span>
{
<span style="color: #3a81c3; font-weight: bold;">public</span>:
    <span style="color: #ba2f59; font-weight: bold;">void</span> <span style="color: #6c3163; font-weight: bold;">DoSomething</span>();
};

<span style="color: #ba2f59; font-weight: bold;">void</span> <span style="color: #4e3163;">NullObject</span>::<span style="color: #6c3163; font-weight: bold;">DoSomething</span>()
{
    <span style="color: #2aa1ae; background-color: #ecf3ec;">//</span><span style="color: #2aa1ae; background-color: #ecf3ec;">do nothing</span>
}
</pre>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">&#33050;&#27880;: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
hook 操作缺省经常是一个空操作。空操作的意义：某些子类可能需要一些"特别"的操作，而大部分子类不需要。
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
继承是在编译时静态扩展父类的职责，装饰者模式是动态的添加职责。
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
实现 MapReduce 中"Map"的一种方式。
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4">4</a></sup> <div class="footpara"><p class="footpara">
具体代码示例参照《Gof 设计模式》5.4 10
</p></div></div>


</div>
</div></div>
</body>
</html>
